<script async type="text/javascript" src="webpolyfill.js"></script> 
<script type="module">
  /*
    async function init() {
      const { instance } = await WebAssembly.instantiateStreaming(
        fetch("./add.wasm")
      );
      console.log(instance.exports.add(4, 1));
    }
    init();
    
  */
  //import {test} from './build/hello/hello.js';

  var WASI_ESUCCESS = 0;
  var WASI_EBADF = 8;
  var WASI_EINVAL = 28;
  var WASI_ENOSYS = 52;
  var WASI_STDOUT_FILENO = 1;

  function bufftostr(buff){
    let dec = new TextDecoder();
    return dec.decode(buff);
  }

  var obj; //WebAssembly.WebAssemblyInstantiatedSource
  var dataView;
  function updateDataView(){
    if(!dataView){
      dataView=new DataView(mem.buffer);
      setInstance(obj.instance, mem);
      return;
    }

    if(dataView.buffer!=mem.buffer){
      dataView=new DataView(mem.buffer);
      setInstance(obj.instance, mem);
    }
  }

  class barebonesWASI {
    moduleInstanceExports = null;
    mem = null;

    setModuleInstance(instance, mem) {
      this.moduleInstanceExports = instance.exports;
      this.mem = mem;
    }

    getModuleMemoryDataView() {
      // call this any time you'll be reading or writing to a module's memory 
      // the returned DataView tends to be dissaociated with the module's memory buffer at the will of the WebAssembly engine 
      // cache the returned DataView at your own peril!!
      return new DataView(this.mem.buffer);
    }

    fd_prestat_get(fd, bufPtr) {
      debugger;
      return WASI_EBADF;
    }

    fd_prestat_dir_name(fd, pathPtr, pathLen) {
      debugger;
      return WASI_EINVAL;
    }

    environ_sizes_get(environCount, environBufSize) {
      debugger;
      updateDataView();
      var view = dataView;

      view.setUint32(environCount, 0, !0);
      view.setUint32(environBufSize, 0, !0);

      return WASI_ESUCCESS;
    }

    environ_get(environ, environBuf) {
      debugger;
      return WASI_ESUCCESS;
    }

    args_sizes_get(argc, argvBufSize) {
      debugger;
      updateDataView();
      var view = dataView;

      view.setUint32(argc, 0, !0);
      view.setUint32(argvBufSize, 0, !0);

      return WASI_ESUCCESS;
    }

    args_get(argv, argvBuf) {
      debugger;
      return WASI_ESUCCESS;
    }

    fd_fdstat_get(fd, bufPtr) {
      debugger;
      updateDataView();
      var view = dataView;

      /*
      filetype 
        0 未知
        1 blockdevice
        2 字符设备 tty
        3 目录节点
        4 普通文件
        5 datagram socket
        6 byte-stream socket
        7 symbolic link inode

      */

      view.setUint32(bufPtr,4,true);  //fs_filetype。 实际是uint8，但是可能需要占用4个字节    TODO 要根据实际类型
      view.setUint32(bufPtr+4,0xffffffff,true);//fs_flags 实际是uint16. 可能要占用4个字节
      view.setUint32(bufPtr+8,0xffffffff,true); // fs_rights_base low
      view.setUint32(bufPtr+12,0xffffffff,true);// fs_rights_base high
      view.setUint32(bufPtr+16,0xffffffff,true); // fs_rights_inheriting low
      view.setUint32(bufPtr+20,0xffffffff,true);// fs_rights_inheriting high

      return WASI_ESUCCESS;
    }

    // 写文件
    //iovs 是一个结构：{ptr*,len}
    fd_write(fd, iovs, iovsLen, nwritten) {
      debugger;
      updateDataView();
      var view = dataView;

      var written = 0;
      var bufferBytes = [];

      function getiovs(iovs, iovsLen) {
        // iovs* -> [iov, iov, ...]
        // __wasi_ciovec_t {
        //   void* buf,
        //   size_t buf_len,
        // }
        var buffers = Array.from({ length: iovsLen }, function (_, i) {
          var ptr = iovs + i * 8;
          var buf = view.getUint32(ptr, !0);
          var bufLen = view.getUint32(ptr + 4, !0);
          return new Uint8Array( mem.buffer, buf, bufLen);
        });
        return buffers;
      }

      var buffers = getiovs(iovs, iovsLen);
      function writev(iov) {
        for (var b = 0; b < iov.byteLength; b++) {
          bufferBytes.push(iov[b]);
        }
        written += b;
      }

      buffers.forEach(writev);
      //if (fd === WASI_STDOUT_FILENO) console.log(String.fromCharCode.apply(null, bufferBytes));
      let str = bufftostr( new Uint8Array(bufferBytes));
      let obj = JSON.parse(str);
      console.log(obj);
      console.log('完成')

      view.setUint32(nwritten, written, !0);

      return WASI_ESUCCESS;
    }

    poll_oneoff(sin, sout, nsubscriptions, nevents) {
      debugger;
      return WASI_ENOSYS;
    }

    proc_exit(rval) {
      debugger;
      return WASI_ENOSYS;
    }

    fd_read(fd) {
      debugger;
    }

    fd_close(fd) {
      debugger;
      return WASI_ENOSYS;
    }

    fd_seek(fd, offset, whence, newOffsetPtr) {
      debugger;
    }

    fd_close(fd) {
      debugger;
      return WASI_ENOSYS;
    }

    // 打开路径。
    // path 是char*
    // 返回0表示成功。 打开的fd保存在retptr0中
    path_open(fd,dirflags,path,path_len,oflags, fs_rights_base, fs_rights_inheriting, fdflags, retptr0) {
      debugger;
      updateDataView();
      let pathstr = UTF8ToString(path);
      if(pathstr.length!=path_len){
        console.error('路径长度不对');
        return -1;
      }
      console.log('打开路径',pathstr);
      let fdtest = 201;// 临时fd。 如果成功的话，后面会stat 201， write 201
      dataView.setUint32(retptr0,fdtest,true);
      return 0;
    }

    path_filestat_get(p1, p2) { debugger; }
    path_unlink_file(p1, p2) { debugger; }
    path_remove_directory(p1, p2) { debugger; }
    path_create_directory(p1, p2) { debugger; }
    fd_fdstat_set_flags(p1, p2) { debugger; }
    clock_time_get(p1, p2) { debugger; }
  }




  var wasiPolyfill = new barebonesWASI();
  let utf8decoder = new TextDecoder("utf-8");
  let mem = new WebAssembly.Memory({ 'initial': 32 });
  //imports['memory'] = 

  async function init() {
    const response = await fetch("./build/assimp.wasm");
    const buffer = await response.arrayBuffer();
    obj = await WebAssembly.instantiate(buffer, {
      JSRT: {
        log: (str, len, f1, f2, f3) => {
          let arr = mem.buffer.slice(str, str + len);
          console.log(utf8decoder.decode(arr), f1, f2, f3);
        },
        logs: (str) => {
          //console.log(str);
          console.log(UTF8ToString(str));
        },
        realpath(path, resolved_path) {
          debugger;
        },
        loadFile(f){
          console.log('loadFile', UTF8ToString(f));
          debugger;
        },
        seek(offset,origin){
          console.log('seek', offset, origin)
        },
        tell(){
          debugger;
          return 0;
        },
        filesize(){
          debugger
          return 0;
        },
        flush(){
          debugger;
        }
      },
      wasi_snapshot_preview1: {
        fd_close: wasiPolyfill.fd_close.bind(wasiPolyfill),
        fd_seek: wasiPolyfill.fd_seek.bind(wasiPolyfill),
        fd_fdstat_get: wasiPolyfill.fd_fdstat_get.bind(wasiPolyfill),
        fd_prestat_get: wasiPolyfill.fd_prestat_get.bind(wasiPolyfill),
        fd_prestat_dir_name: wasiPolyfill.fd_prestat_dir_name.bind(wasiPolyfill),
        fd_write: wasiPolyfill.fd_write.bind(wasiPolyfill),
        proc_exit: wasiPolyfill.proc_exit.bind(wasiPolyfill),
        path_open: wasiPolyfill.path_open.bind(wasiPolyfill),
        path_filestat_get: wasiPolyfill.path_filestat_get.bind(wasiPolyfill),
        path_unlink_file: wasiPolyfill.path_unlink_file.bind(wasiPolyfill),
        path_remove_directory: wasiPolyfill.path_remove_directory.bind(wasiPolyfill),
        path_create_directory: wasiPolyfill.path_create_directory.bind(wasiPolyfill),
        fd_fdstat_set_flags: wasiPolyfill.fd_fdstat_set_flags.bind(wasiPolyfill),
        fd_read: wasiPolyfill.fd_read.bind(wasiPolyfill),
        clock_time_get: wasiPolyfill.clock_time_get.bind(wasiPolyfill),
        environ_sizes_get: wasiPolyfill.environ_sizes_get.bind(wasiPolyfill),
        environ_get: wasiPolyfill.environ_get.bind(wasiPolyfill),
        __wasm_lpad_context: () => { }
      },
      env: {
        memory: mem,
        __cxa_begin_catch: () => { debugger; },
        __cxa_end_catch: () => { debugger; },
        __cxa_throw: () => { debugger; },
        __cxa_rethrow: () => { debugger; },
        __cxa_allocate_exception: () => { debugger; },
        __cxa_free_exception: () => { debugger; },
        __multi3: () => { debugger; },
        __lttf2: () => { debugger; },
        realpath: () => { debugger; },
        _Unwind_CallPersonality: () => { debugger; },
      }
    });
    //polyfill
    setInstance(obj.instance,mem)
    dataView = new DataView(mem.buffer);
    let exports = obj.instance.exports;

    wasiPolyfill.setModuleInstance(obj.instance, mem);
    //TEST
    let pp = exports._malloc(16)
    stringToUTF8('aaa',pp, lengthBytesUTF8('aaa')+1);
    console.log(UTF8ToString(pp));
    
    // 
    const fbx = await fetch("./res/xiepian.fbx");
    const fbxbuff = await fbx.arrayBuffer();
    let ptr = exports._malloc(fbxbuff.byteLength);
    cpyUint8(ptr, new Uint8Array(fbxbuff));
    exports.setData(ptr,fbxbuff.byteLength);
    
    console.log(obj.instance.exports.test());  // "3" 
    debugger;

  }
  init();
</script>